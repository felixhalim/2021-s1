{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unix 101: The NUS SoC Unix@Home Workshop AY20/21 Semester 1 About The NUS SoC Unix Workshop is a workshop organized by faculty members of the School of Computing, National University of Singapore, for first-year students. This year, we will conduct the \"Unix@Home\" version, entirely online via Zoom. Objectives The aims of the workshop are To introduce students to using Unix-based computing environment for daily computing tasks To prepare students to be efficient in using Unix for their computing career After taking the workshop, students are expected to: Understand common terminology: Unix, Linux, Ubuntu, SunOS, ssh, host, command line, shell, operating systems, etc. Appreciate the advantages of the Unix environment Understand the Unix file organization Able to perform common file management tasks (create/copy/move/remove/change permission, etc) through Unix shell (For Windows 10 users) Setup local Unix environment Setup apt (Win10) or Homebrew (macOS) and able to use it to install library or applications Time and Venue There will be two versions of the workshop, one for macOS users, the other for Windows 10 users. The date and time are as follows: 3-4 August , 2020 (Mon - Tue), 9:00 to 11:30 am each day. for macOS users only 6-7 August , 2020 (Thu - Fri), 9:00 to 11:30 am each day. for Windows 10 users only The workshop will be conducted online via Zoom. Registration First-year students taking CS1010, CS2030, CS2030S, and CS2040 in Semester 1 of AY2020/21 will be given priority to register for and to attend the workshop. The workshop is sponsored by the NUS School of Computing and is free to attend. Space, however, is limited -- please register only if you are committed to attending. lease register here. before 28 July, 2020 . License The content of this site is licensed under the Creative Common Attribution-NonCommercial-ShareAlike 4.0 International license","title":"Home"},{"location":"#unix-101-the-nus-soc-unixhome-workshop","text":"","title":"Unix 101: The NUS SoC Unix@Home Workshop"},{"location":"#ay2021-semester-1","text":"","title":"AY20/21 Semester 1"},{"location":"#about","text":"The NUS SoC Unix Workshop is a workshop organized by faculty members of the School of Computing, National University of Singapore, for first-year students. This year, we will conduct the \"Unix@Home\" version, entirely online via Zoom.","title":"About"},{"location":"#objectives","text":"The aims of the workshop are To introduce students to using Unix-based computing environment for daily computing tasks To prepare students to be efficient in using Unix for their computing career After taking the workshop, students are expected to: Understand common terminology: Unix, Linux, Ubuntu, SunOS, ssh, host, command line, shell, operating systems, etc. Appreciate the advantages of the Unix environment Understand the Unix file organization Able to perform common file management tasks (create/copy/move/remove/change permission, etc) through Unix shell (For Windows 10 users) Setup local Unix environment Setup apt (Win10) or Homebrew (macOS) and able to use it to install library or applications","title":"Objectives"},{"location":"#time-and-venue","text":"There will be two versions of the workshop, one for macOS users, the other for Windows 10 users. The date and time are as follows: 3-4 August , 2020 (Mon - Tue), 9:00 to 11:30 am each day. for macOS users only 6-7 August , 2020 (Thu - Fri), 9:00 to 11:30 am each day. for Windows 10 users only The workshop will be conducted online via Zoom.","title":"Time and Venue"},{"location":"#registration","text":"First-year students taking CS1010, CS2030, CS2030S, and CS2040 in Semester 1 of AY2020/21 will be given priority to register for and to attend the workshop. The workshop is sponsored by the NUS School of Computing and is free to attend. Space, however, is limited -- please register only if you are committed to attending. lease register here. before 28 July, 2020 .","title":"Registration"},{"location":"#license","text":"The content of this site is licensed under the Creative Common Attribution-NonCommercial-ShareAlike 4.0 International license","title":"License"},{"location":"chmod/","text":"Unit 6: File Permission Management File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right. The What of File Permissions Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3. The Who of File Permissions Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read Checking file permission You can view the permission of a file by using the ls -l command ( l for long format): $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644. The chmod command You can use chmod command to change the permissions of a file or a directory. For instance, $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Common Scenarios for chmod Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x . Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9","title":"6. File Permissions"},{"location":"chmod/#unit-6-file-permission-management","text":"File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right.","title":"Unit 6: File Permission Management"},{"location":"chmod/#the-what-of-file-permissions","text":"Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3.","title":"The What of File Permissions"},{"location":"chmod/#the-who-of-file-permissions","text":"Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read","title":"The Who of File Permissions"},{"location":"chmod/#checking-file-permission","text":"You can view the permission of a file by using the ls -l command ( l for long format): $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644.","title":"Checking file permission"},{"location":"chmod/#the-chmod-command","text":"You can use chmod command to change the permissions of a file or a directory. For instance, $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt","title":"The chmod command"},{"location":"chmod/#common-scenarios-for-chmod","text":"Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x . Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9","title":"Common Scenarios for chmod"},{"location":"efficiency/","text":"Unit 10: Leveling Up Your Productivy with CLI Minimizing Hand Movements In Day 1 of the workshop, you have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. Actually, you do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type. We do not need to move our palsm, wrists or our elbows! Minimizing Typing We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use ++control-p++ or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivy, if you are keen, take a look here: https://github.com/fliptheweb/bash-shortcuts-cheat-sheet You have also seen in Day 1 of the workshop that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again, or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: $ bash hello.sh hello! or $ bash < hello.sh hello! Recall that we said Unix shells do not necessary interact with the users? This is an example. We basically pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions unit that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: $ chmod u+x hello.sh $ ./hello.sh hello! Now we can run our script without typing bash . We can actually remove ./ as well, but we will learn about that only when we talk about environment variables . Terminal-based Editor: vim The above examples show us how we can create simple, one-line, shell script. Shell scripts can be fairly complex -- bash supports a full-blown programming language. To edit shell scripts, programs, or text files, we need a proper editor. Remember that we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys. There are only two respectable, widely available text editors in Unix -- vim and emacs , which one is better has been an ongoing religous war, but for us in SoC, we use vim . You will get to practice using vim in the next session, but for a start, I will go through the key ideas of vim . 1. Minimizing Hand Movements vim , like the shell, aims to minimize hand movements. Frequently used commands are positioned in the convinient places on the keyboard. Let me give you a few examples. To exit vim, type Shift + Z + Z . Notice that this is located at the bottom left corner of your keyboard. For normal typing, your left hand is supposed to be placed over the keys A S D F , so you just need move slightly your left pinky to Shift and left ring finger to Z and hit them. To move the cursor, instead of using the arrow keys, vim uses H to move left, L to move right, J to move down, and K to move up. For normal typing, you right hand is supposed to be placed on J K L ++;++, so these arrow keys alternatives are located very near to where your right hand should be! I have a few more things to say about using H J K L to replace the arrow keys: It is not uncommon for applications to re-map other keys for movement. Many first-person shooting games uses W A S D for movement, for the same reason as vim -- it is close to the resting position of the left hand on the keyboard. The use of H J K L for movement is more ubiquitous than you think. In the Web-version of Facebook and Reddit, for instance, you can use J and K to move up and down across posts. On this website, you can use H and L to go to the previous page and the next page respectively. 2. Multi-modal Editor vim is a multi-modal editor. While for most other editors makes no distinction between reading and editing, vim makes an explicit distinction between the two. vim has two modes: NORMAL mode: where you read, navigate, and manipulate the text. INSERT mode: where you insert the text As a programmer, having a different NORMAL modes makes sense since we spend much time reading and navigating around source code. Thus, allowing the editing commands to optimized. The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"Unit 10: Leveling Up Your Productivy with CLI"},{"location":"efficiency/#unit-10-leveling-up-your-productivy-with-cli","text":"","title":"Unit 10: Leveling Up Your Productivy with CLI"},{"location":"efficiency/#minimizing-hand-movements","text":"In Day 1 of the workshop, you have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. Actually, you do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type. We do not need to move our palsm, wrists or our elbows!","title":"Minimizing Hand Movements"},{"location":"efficiency/#minimizing-typing","text":"We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use ++control-p++ or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivy, if you are keen, take a look here: https://github.com/fliptheweb/bash-shortcuts-cheat-sheet You have also seen in Day 1 of the workshop that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again, or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: $ bash hello.sh hello! or $ bash < hello.sh hello! Recall that we said Unix shells do not necessary interact with the users? This is an example. We basically pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions unit that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: $ chmod u+x hello.sh $ ./hello.sh hello! Now we can run our script without typing bash . We can actually remove ./ as well, but we will learn about that only when we talk about environment variables .","title":"Minimizing Typing"},{"location":"efficiency/#terminal-based-editor-vim","text":"The above examples show us how we can create simple, one-line, shell script. Shell scripts can be fairly complex -- bash supports a full-blown programming language. To edit shell scripts, programs, or text files, we need a proper editor. Remember that we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys. There are only two respectable, widely available text editors in Unix -- vim and emacs , which one is better has been an ongoing religous war, but for us in SoC, we use vim . You will get to practice using vim in the next session, but for a start, I will go through the key ideas of vim .","title":"Terminal-based Editor: vim"},{"location":"efficiency/#1-minimizing-hand-movements","text":"vim , like the shell, aims to minimize hand movements. Frequently used commands are positioned in the convinient places on the keyboard. Let me give you a few examples. To exit vim, type Shift + Z + Z . Notice that this is located at the bottom left corner of your keyboard. For normal typing, your left hand is supposed to be placed over the keys A S D F , so you just need move slightly your left pinky to Shift and left ring finger to Z and hit them. To move the cursor, instead of using the arrow keys, vim uses H to move left, L to move right, J to move down, and K to move up. For normal typing, you right hand is supposed to be placed on J K L ++;++, so these arrow keys alternatives are located very near to where your right hand should be! I have a few more things to say about using H J K L to replace the arrow keys: It is not uncommon for applications to re-map other keys for movement. Many first-person shooting games uses W A S D for movement, for the same reason as vim -- it is close to the resting position of the left hand on the keyboard. The use of H J K L for movement is more ubiquitous than you think. In the Web-version of Facebook and Reddit, for instance, you can use J and K to move up and down across posts. On this website, you can use H and L to go to the previous page and the next page respectively.","title":"1. Minimizing Hand Movements"},{"location":"efficiency/#2-multi-modal-editor","text":"vim is a multi-modal editor. While for most other editors makes no distinction between reading and editing, vim makes an explicit distinction between the two. vim has two modes: NORMAL mode: where you read, navigate, and manipulate the text. INSERT mode: where you insert the text As a programmer, having a different NORMAL modes makes sense since we spend much time reading and navigating around source code. Thus, allowing the editing commands to optimized. The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"2. Multi-modal Editor"},{"location":"file-management/","text":"Unit 5: Unix File Management This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. $ ls test.txt cp : CoPy files Now let's try to copy this file to another name. $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning. mv : MoVe or rename files Now, let's change directory back to workshop . $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command. rm : ReMove files We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively. cat : CATenate file content to screen To quickly take a look at the content of the file, use the cat command. $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q .","title":"5. File Management"},{"location":"file-management/#unit-5-unix-file-management","text":"This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. $ ls test.txt","title":"Unit 5: Unix File Management"},{"location":"file-management/#cp-copy-files","text":"Now let's try to copy this file to another name. $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning.","title":"cp: CoPy files"},{"location":"file-management/#mv-move-or-rename-files","text":"Now, let's change directory back to workshop . $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.","title":"mv: MoVe or rename files"},{"location":"file-management/#rm-remove-files","text":"We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively.","title":"rm: ReMove files"},{"location":"file-management/#cat-catenate-file-content-to-screen","text":"To quickly take a look at the content of the file, use the cat command. $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to screen"},{"location":"file-management/#man-online-manual","text":"An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q .","title":"man: Online MANual"},{"location":"mac/","text":"Setting Up Unix Computing Environment on macOS macOS is a Unix-based operating system. Not setup is required. To access the Unix command line interface, hit F4 to access LaunchPad, and type Terminal followed by Enter . Install Command Line Development Tool Run xcode-select --install to install a set of command-line tools used for software development in macOS. Install Homebrew Homebrew is a command-line software manager for macOS. If you have not installed Homebrew before, paste the following into your shell to install it. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \"","title":"Setup for macOS"},{"location":"mac/#setting-up-unix-computing-environment-on-macos","text":"macOS is a Unix-based operating system. Not setup is required. To access the Unix command line interface, hit F4 to access LaunchPad, and type Terminal followed by Enter .","title":"Setting Up Unix Computing Environment on macOS"},{"location":"mac/#install-command-line-development-tool","text":"Run xcode-select --install to install a set of command-line tools used for software development in macOS.","title":"Install Command Line Development Tool"},{"location":"mac/#install-homebrew","text":"Homebrew is a command-line software manager for macOS. If you have not installed Homebrew before, paste the following into your shell to install it. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \"","title":"Install Homebrew"},{"location":"path-nav/","text":"Unit 4: Unix Directory Structure and Navigation Unix Directory Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know. Root Directory The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify. Home Directory Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob . Current Working Directory A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash . Parent Directory The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory Specifying a Path To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path . Absolute path The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~ Relative path The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / . Directory-related Commands Now, let's take a look at some basic commands available in bash that deals with navigation and directories. pwd : Print Current Working directory pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering pwd will give the output /home/o/ooiwt ls : LiSt content of a directory The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command. cd : Change Directory To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in the Introduction to Shell unit, it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory. rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command Bashs $ rmdir workshop will remove the directory that you just created. In computing, trees are upside down with the root at the top and leaves at the bottom! \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"4. Path and Navigation"},{"location":"path-nav/#unit-4-unix-directory-structure-and-navigation","text":"","title":"Unit 4: Unix Directory Structure and Navigation"},{"location":"path-nav/#unix-directory","text":"Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know.","title":"Unix Directory"},{"location":"path-nav/#root-directory","text":"The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify.","title":"Root Directory"},{"location":"path-nav/#home-directory","text":"Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob .","title":"Home Directory"},{"location":"path-nav/#current-working-directory","text":"A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash .","title":"Current Working Directory"},{"location":"path-nav/#parent-directory","text":"The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory","title":"Parent Directory"},{"location":"path-nav/#specifying-a-path","text":"To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path .","title":"Specifying a Path"},{"location":"path-nav/#absolute-path","text":"The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~","title":"Absolute path"},{"location":"path-nav/#relative-path","text":"The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / .","title":"Relative path"},{"location":"path-nav/#directory-related-commands","text":"Now, let's take a look at some basic commands available in bash that deals with navigation and directories.","title":"Directory-related Commands"},{"location":"path-nav/#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering pwd will give the output /home/o/ooiwt","title":"pwd: Print Current Working directory"},{"location":"path-nav/#ls-list-content-of-a-directory","text":"The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")","title":"ls: LiSt content of a directory"},{"location":"path-nav/#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command.","title":"mkdir: MaKe a subDIRectory"},{"location":"path-nav/#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in the Introduction to Shell unit, it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory.","title":"cd: Change Directory"},{"location":"path-nav/#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command Bashs $ rmdir workshop will remove the directory that you just created. In computing, trees are upside down with the root at the top and leaves at the bottom! \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"rmdir: ReMove a subDIRectory"},{"location":"pattern/","text":"Unit 9: Pattern Matching in bash We now show you another productivity shortcut. In an example earlier , you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of $ cat test.txt foo.txt bar.txt | wc We could just run $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , . Example 1: $ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt . Example 2: $ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t . Example 3: $ ls {fo,ba}??txt foo.txt test.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt .","title":"9. Pattern Matching"},{"location":"pattern/#unit-9-pattern-matching-in-bash","text":"We now show you another productivity shortcut. In an example earlier , you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of $ cat test.txt foo.txt bar.txt | wc We could just run $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , .","title":"Unit 9: Pattern Matching in bash"},{"location":"pattern/#example-1","text":"$ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt .","title":"Example 1:"},{"location":"pattern/#example-2","text":"$ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t .","title":"Example 2:"},{"location":"pattern/#example-3","text":"$ ls {fo,ba}??txt foo.txt test.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt .","title":"Example 3:"},{"location":"pipe/","text":"Unit 8: Composing Programs with | Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting. Useful Utilities Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix. head and tail head and tail prints out the first k k lines and last k k lines from a file (or standard input if the file name is not given). By default, k k is 10, but you can pass in an argument to specify k k . $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands. echo echo simply prints out the command-line argument to the standard output. $ echo \"hello world!\" hello world! sort sort rearrange the input lines in alphabetical order. $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order. uniq uniq remove any two consecutive lines that are the same. $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.` grep grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done. Pipe Example To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: $ cat ID | sort | uniq | grep CEG | wc -l 3","title":"8. Composition with Pipe"},{"location":"pipe/#unit-8-composing-programs-with","text":"Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting.","title":"Unit 8: Composing Programs with |"},{"location":"pipe/#useful-utilities","text":"Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix.","title":"Useful Utilities"},{"location":"pipe/#head-and-tail","text":"head and tail prints out the first k k lines and last k k lines from a file (or standard input if the file name is not given). By default, k k is 10, but you can pass in an argument to specify k k . $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands.","title":"head and tail"},{"location":"pipe/#echo","text":"echo simply prints out the command-line argument to the standard output. $ echo \"hello world!\" hello world!","title":"echo"},{"location":"pipe/#sort","text":"sort rearrange the input lines in alphabetical order. $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order.","title":"sort"},{"location":"pipe/#uniq","text":"uniq remove any two consecutive lines that are the same. $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.`","title":"uniq"},{"location":"pipe/#grep","text":"grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done.","title":"grep"},{"location":"pipe/#pipe-example","text":"To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: $ cat ID | sort | uniq | grep CEG | wc -l 3","title":"Pipe Example"},{"location":"schedule/","text":"Tentative Schedule for Unix@Home Workshop (Note: Allocated time is a very rough approxmiate) Day 1 Plenary Session 1: Introduction (20 minutes) 1: What is Unix? Why are we learning/using Unix? 2: What is CLI? Why are we learning/using CLI? 3: What is a terminal? What is a shell? Breakout Session 2: Basic Unix Files Operations I (30 minutes) Setup a Unix computing environment on Windows 10 or macOS Installing tmate for terminal sharing 4: Directories, paths, and navigation Break (20 minutes) Breakout Session 3: Basic Unix Files Operations II (20 minutes) 5: File management 6: Permission management Break (20 minutes) Breakout Session 4: Composition (30 minutes) 7: Standard I/O 8: Piping 9: Pattern Matching DAY 2 Plenary Session 5: Gaining Efficiency with Unix (10 minutes) 10: Producitivity with Unix 11: The philosophy and power of vim Breakout Session 5: Simple file editing with vim (30 minutes) Running and quitting vim Insert mode and command mode (i and esc) Moving cursor around with hjkl Break (20 minutes) Breakout Session 6: Very Basic Shell Scripts (30 minutes) Putting a sequence of commands in a file and executing the file Command-line arguments and variables Break (20 minutes) Breakout Session 7: Extending your Unix Environment (20 minutes) Using apt (WSL) and brew (macOS), curl install, list, search, uninstall Breakout Session 8: Remote Servers (10 minutes) Concepts of hosts, client, server. Accessing a remote server via ssh Ssh into sdf.org Preview of SoC Unix environments ( stu0 ) Break (20 minutes) Plenary Session 9: Conclusion and The Unix Philosophy (15 minutes) The Unix Philosophy Do one thing well Use simple text file Make every program a filter and make them work together Avoid unnecessary output","title":"Schedule"},{"location":"schedule/#tentative-schedule-for-unixhome-workshop","text":"(Note: Allocated time is a very rough approxmiate)","title":"Tentative Schedule for Unix@Home Workshop"},{"location":"schedule/#day-1","text":"","title":"Day 1"},{"location":"schedule/#plenary-session-1-introduction-20-minutes","text":"1: What is Unix? Why are we learning/using Unix? 2: What is CLI? Why are we learning/using CLI? 3: What is a terminal? What is a shell?","title":"Plenary Session 1: Introduction (20 minutes)"},{"location":"schedule/#breakout-session-2-basic-unix-files-operations-i-30-minutes","text":"Setup a Unix computing environment on Windows 10 or macOS Installing tmate for terminal sharing 4: Directories, paths, and navigation","title":"Breakout Session 2: Basic Unix Files Operations I (30 minutes)"},{"location":"schedule/#break-20-minutes","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-3-basic-unix-files-operations-ii-20-minutes","text":"5: File management 6: Permission management","title":"Breakout Session 3:  Basic Unix Files Operations II (20 minutes)"},{"location":"schedule/#break-20-minutes_1","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-4-composition-30-minutes","text":"7: Standard I/O 8: Piping 9: Pattern Matching","title":"Breakout Session 4: Composition (30 minutes)"},{"location":"schedule/#day-2","text":"","title":"DAY 2"},{"location":"schedule/#plenary-session-5-gaining-efficiency-with-unix-10-minutes","text":"10: Producitivity with Unix 11: The philosophy and power of vim","title":"Plenary Session 5: Gaining Efficiency with Unix (10 minutes)"},{"location":"schedule/#breakout-session-5-simple-file-editing-with-vim-30-minutes","text":"Running and quitting vim Insert mode and command mode (i and esc) Moving cursor around with hjkl","title":"Breakout Session 5: Simple file editing with vim (30 minutes)"},{"location":"schedule/#break-20-minutes_2","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-6-very-basic-shell-scripts-30-minutes","text":"Putting a sequence of commands in a file and executing the file Command-line arguments and variables","title":"Breakout Session 6: Very Basic Shell Scripts (30 minutes)"},{"location":"schedule/#break-20-minutes_3","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-7-extending-your-unix-environment-20-minutes","text":"Using apt (WSL) and brew (macOS), curl install, list, search, uninstall","title":"Breakout Session 7: Extending your Unix Environment (20 minutes)"},{"location":"schedule/#breakout-session-8-remote-servers-10-minutes","text":"Concepts of hosts, client, server. Accessing a remote server via ssh Ssh into sdf.org Preview of SoC Unix environments ( stu0 )","title":"Breakout Session 8: Remote Servers (10 minutes)"},{"location":"schedule/#break-20-minutes_4","text":"","title":"Break (20 minutes)"},{"location":"schedule/#plenary-session-9-conclusion-and-the-unix-philosophy-15-minutes","text":"The Unix Philosophy Do one thing well Use simple text file Make every program a filter and make them work together Avoid unnecessary output","title":"Plenary Session 9: Conclusion and The Unix Philosophy (15 minutes)"},{"location":"shell/","text":"Unit 3: Terminal and Shell What is a Terminal? With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence. What is a Shell? The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. I (Wei Tsang) personally use fish for my day-to-day work. Oh-my-zsh ( zsh ) is another shell popular among experienced users. Command Prompt A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell. Terminal Control Sequence On the old teletype machines (see history of command-line interfaces ), a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this contorl sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal.","title":"3. Terminal and Shell"},{"location":"shell/#unit-3-terminal-and-shell","text":"","title":"Unit 3: Terminal and Shell"},{"location":"shell/#what-is-a-terminal","text":"With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence.","title":"What is a Terminal?"},{"location":"shell/#what-is-a-shell","text":"The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. I (Wei Tsang) personally use fish for my day-to-day work. Oh-my-zsh ( zsh ) is another shell popular among experienced users.","title":"What is a Shell?"},{"location":"shell/#command-prompt","text":"A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell.","title":"Command Prompt"},{"location":"shell/#terminal-control-sequence","text":"On the old teletype machines (see history of command-line interfaces ), a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this contorl sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal.","title":"Terminal Control Sequence"},{"location":"stdio/","text":"Unit 7: Standard Input/Output History Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal . Examples using cat and wc Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered. Output Redirection By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt Input Redirection The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator.","title":"7. Standard I/O"},{"location":"stdio/#unit-7-standard-inputoutput","text":"","title":"Unit 7: Standard Input/Output"},{"location":"stdio/#history","text":"Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal .","title":"History"},{"location":"stdio/#examples-using-cat-and-wc","text":"Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered.","title":"Examples using cat and wc"},{"location":"stdio/#output-redirection","text":"By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt","title":"Output Redirection"},{"location":"stdio/#input-redirection","text":"The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator.","title":"Input Redirection"},{"location":"tmate/","text":"Setting Up tmate Before you continue, read about what is a terminal . Make sure you have set up apt if you use WSL and brew if you use macOS. What is tmate ? tmate is a tool that allows you to share your terminal with others. This allows another person to have enter text into your terminal and to see the output returned by your terminal. We will use tmate to allow tutors to view and type into your terminal. Giving someone else full control of your computer is dangerous -- so you need to be sure that you are sharing your terminal with someone you trust (e.g., your professor and your tutor). Do NOT share your tmate link publicly. Installing tmate on WSL or Ubuntu Run the following in your terminal: sudo apt install tmate Installing tmate on macOS Run the following in your terminal: brew install tmate Running tmate To share your screen with someone you trust, run: tmate You should then see the following messages: Tip: if you wish to use tmate only for remote access, run: tmate -F [0/0] To see the following messages again, run in a tmate session: tmate show-messages Press <q> or <ctrl-c> to continue --------------------------------------------------------------------- Connecting to ssh.tmate.io... Note: clear your terminal before sharing readonly access web session read only: https://tmate.io/t/ro-Zv6kbZxwLtc84NXnnFJtGvnYE ssh session read only: ssh ro-Zv6kbZxwLtc84NXnnFJtGvnYE@sgp1.tmate.io web session: https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ssh session: ssh 3svwMBrjhwgp93QmZFHLnwzRP@sgp1.tmate.io Note that your output will not be exactly the same as the above, particular, the seemingly gibberish text is randomly generated when you run tmate , so it will be a different gibberish every time. There are several important piece of information here: There are a list of links for you to share with your tutors. Suppose your tutor wants to see (but not control) your screen through a web browser, you can send the link marked as web session read only: to him or her (e.g., via private chat in Zoom). If your tutor needs to show you something on your shell through a web browser, you can send the link marked as web session: to him or her. (In the example above: send https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ) If you do not copy down the links and need to access them later, just run tmate show-messages . Note that the links are randomly generated and are different every time you run tmate . Once you have copied and send the link to your tutor, press Q or Ctrl + C to continue. Your terminal is now shared with your tutor. You can tell this as there is a small bar at the bottom of your terminal's screen. To stop sharing, hit Ctrl + D at the command prompt 1 . Here is a small screencast to demonstrate this: For an overview of all special terminal Ctrl commands, see terminal control sequence . \u21a9","title":"Setup tmate"},{"location":"tmate/#setting-up-tmate","text":"Before you continue, read about what is a terminal . Make sure you have set up apt if you use WSL and brew if you use macOS.","title":"Setting Up tmate"},{"location":"tmate/#what-is-tmate","text":"tmate is a tool that allows you to share your terminal with others. This allows another person to have enter text into your terminal and to see the output returned by your terminal. We will use tmate to allow tutors to view and type into your terminal. Giving someone else full control of your computer is dangerous -- so you need to be sure that you are sharing your terminal with someone you trust (e.g., your professor and your tutor). Do NOT share your tmate link publicly.","title":"What is tmate?"},{"location":"tmate/#installing-tmate-on-wsl-or-ubuntu","text":"Run the following in your terminal: sudo apt install tmate","title":"Installing tmate on WSL or Ubuntu"},{"location":"tmate/#installing-tmate-on-macos","text":"Run the following in your terminal: brew install tmate","title":"Installing tmate on macOS"},{"location":"tmate/#running-tmate","text":"To share your screen with someone you trust, run: tmate You should then see the following messages: Tip: if you wish to use tmate only for remote access, run: tmate -F [0/0] To see the following messages again, run in a tmate session: tmate show-messages Press <q> or <ctrl-c> to continue --------------------------------------------------------------------- Connecting to ssh.tmate.io... Note: clear your terminal before sharing readonly access web session read only: https://tmate.io/t/ro-Zv6kbZxwLtc84NXnnFJtGvnYE ssh session read only: ssh ro-Zv6kbZxwLtc84NXnnFJtGvnYE@sgp1.tmate.io web session: https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ssh session: ssh 3svwMBrjhwgp93QmZFHLnwzRP@sgp1.tmate.io Note that your output will not be exactly the same as the above, particular, the seemingly gibberish text is randomly generated when you run tmate , so it will be a different gibberish every time. There are several important piece of information here: There are a list of links for you to share with your tutors. Suppose your tutor wants to see (but not control) your screen through a web browser, you can send the link marked as web session read only: to him or her (e.g., via private chat in Zoom). If your tutor needs to show you something on your shell through a web browser, you can send the link marked as web session: to him or her. (In the example above: send https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ) If you do not copy down the links and need to access them later, just run tmate show-messages . Note that the links are randomly generated and are different every time you run tmate . Once you have copied and send the link to your tutor, press Q or Ctrl + C to continue. Your terminal is now shared with your tutor. You can tell this as there is a small bar at the bottom of your terminal's screen. To stop sharing, hit Ctrl + D at the command prompt 1 . Here is a small screencast to demonstrate this: For an overview of all special terminal Ctrl commands, see terminal control sequence . \u21a9","title":"Running tmate"},{"location":"why-cli/","text":"Unit 2: Command-Line Interfaces What is Command-Line Interfaces? The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer. Why CLI over GUI? Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks. References The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"2. Why CLI?"},{"location":"why-cli/#unit-2-command-line-interfaces","text":"","title":"Unit 2: Command-Line Interfaces"},{"location":"why-cli/#what-is-command-line-interfaces","text":"The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer.","title":"What is Command-Line Interfaces?"},{"location":"why-cli/#why-cli-over-gui","text":"Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks.","title":"Why CLI over GUI?"},{"location":"why-cli/#references","text":"The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"References"},{"location":"why-unix/","text":"Unit 1: Unix History of Unix To understand what Unix is and to appreciate its importance, let's take a glimpse into the history book. Early computers, in the 1940s and early 1950s, do not have an operating system. Every program will have to be designed specifically for a given hardware specification and only one program can run on the computer at one time. To run a program, a user will have to carry a stack of punch cards or tapes into the computer room and load them into the computer at a scheduled time. As computers become more sophisticated and the demand to run programs on the machine increases, humans operators are hired to manage the requests to run the programs, and these human operators have to manually schedule and manage the time allocated to each program on the machine. These tasks are slowly being replaced by a layer of software that runs on the computers starting the late 1950s. Termed operating systems , this system software helps to manage \"which program runs when\", and it includes more functionalities such as resource accounting (e.g., which user used how much time on the machine) and hardware management (e.g., hide the tedious operations of interfacing with memory and storage from the programmer). One of the defining development in the 1960s is the idea of time sharing - allowing computer time to be shared by multiple users. Time-sharing is revolutionary since users no longer have to queue or schedule a slotted time to run a program on a computer. The early operating system that enables time-sharing, however, is complex, difficult to use, and bloated with features. Unix is an operating system that was developed in the late 1960s and the early 1970s around this revolution, by Dennis Ritchie and Ken Thompson from Bell Laboratories. Learning from the mistakes of the past operating systems, the duo set to develop an operating system with simplicity and elegance at the core of its design. Part of the push towards simplicity is also due to the lack of powerful computers in many places at that time -- the design constraints have lead to design decisions that favor economy. Figure: Ken thompson (sitting) and Dennis Ritchie working in front of their computer. The simplicity and elegance has propelled the popularity of the Unix operating system, leading to over 600 installations reported by 1974 3 . Closely tied to the rise of Unix is the invention of C, a programming language that Dennis Ritchie and Ken Thompson used to write Unix in. This is revolutionary by itself, as programmers can then write tools and programs in a higher level structured language, rather than in low-level assembly languages as in the operating systems before. As a result of this development, Unix is the first operating system where programmers can write and run a program on the fly in front of a terminal. This ability leads to a plethora of contributions to Unix systems, utilities, and tools in the 1970s, fueling its popularity among the developers. The ease of programming and its superiority in terms of simplicity has lead to the emergence of variants of the original Unix operating systems, developed by modifying the original Unix source code. The Berkeley Software Distribution (BSD) is among the most important ones (macOS is a descendant of BSD). Another notable descendant from the original Unix is Solaris, from Sun Microsystem (now Oracle), which the School of Computing runs on its computing server (called sunfire ). Another variant of Unix is Linux -- which interestingly is developed from scratch as a hobby initially by Linus Torvalds at the age of 21. Linux follows many of the principles of Unix but is not based on the original Unix source code. Figure: Unix and Unix-like Operating Systems. While a majority of personal computers is still running Microsoft Windows 10 (88%), a vast majority of server software is running on some flavor of Unix (>70%) 1 . Almost all mobile phones are running on a variant of Unix (iOS, Android). Among software developers, more than half (53%) uses a Unix-based OS on the primary work machines 2 . Microsoft, after years of competing with Unix-based OS, has started to embrace Unix-based systems and released the Windows Subsystems for Linux, allowing Windows users to run a sandboxed Linux subsystems within Windows. We collectively call these variants of operating systems and subsystems the Unix computing environment , which today includes all OS from Apple (macOS, iOS, etc), Linux-based systems (Ubuntu, Android, etc), commercial servers (Oracle's Solaris, HP's HP-UX, IBM's AIX), and subsystems within Microsoft Windows 10. Why Learn Unix? There are several reasons: Unix-based OS is the dominant operating system in the world, and as a computing student, you will likely have to interface with one sometime in your career. Unix design is rooted in its simplicity and economy. It is probably the most productive programming environment you can have to do most of your day-to-day tasks and to develop software as a computing professional. Unix design is also rooted in its programmability. If there is something that you wish to automate a task to improve your productivity, you can easily compose new tools from the existing ones. The Unix philosophy serves as a great example of how good software should be designed: simple, do one thing well, composable. Further Readings The Art of Unix Programming: History of Unix , by Eric Steven Raymond Stack Overflow Developer Survey 2020 \u21a9 Usage Share of OS , by Wikipedia \u21a9 The Unix Time Sharing System , by Dennis Ritchie and Ken Thompson. \u21a9","title":"1. Why Unix?"},{"location":"why-unix/#unit-1-unix","text":"","title":"Unit 1: Unix"},{"location":"why-unix/#history-of-unix","text":"To understand what Unix is and to appreciate its importance, let's take a glimpse into the history book. Early computers, in the 1940s and early 1950s, do not have an operating system. Every program will have to be designed specifically for a given hardware specification and only one program can run on the computer at one time. To run a program, a user will have to carry a stack of punch cards or tapes into the computer room and load them into the computer at a scheduled time. As computers become more sophisticated and the demand to run programs on the machine increases, humans operators are hired to manage the requests to run the programs, and these human operators have to manually schedule and manage the time allocated to each program on the machine. These tasks are slowly being replaced by a layer of software that runs on the computers starting the late 1950s. Termed operating systems , this system software helps to manage \"which program runs when\", and it includes more functionalities such as resource accounting (e.g., which user used how much time on the machine) and hardware management (e.g., hide the tedious operations of interfacing with memory and storage from the programmer). One of the defining development in the 1960s is the idea of time sharing - allowing computer time to be shared by multiple users. Time-sharing is revolutionary since users no longer have to queue or schedule a slotted time to run a program on a computer. The early operating system that enables time-sharing, however, is complex, difficult to use, and bloated with features. Unix is an operating system that was developed in the late 1960s and the early 1970s around this revolution, by Dennis Ritchie and Ken Thompson from Bell Laboratories. Learning from the mistakes of the past operating systems, the duo set to develop an operating system with simplicity and elegance at the core of its design. Part of the push towards simplicity is also due to the lack of powerful computers in many places at that time -- the design constraints have lead to design decisions that favor economy. Figure: Ken thompson (sitting) and Dennis Ritchie working in front of their computer. The simplicity and elegance has propelled the popularity of the Unix operating system, leading to over 600 installations reported by 1974 3 . Closely tied to the rise of Unix is the invention of C, a programming language that Dennis Ritchie and Ken Thompson used to write Unix in. This is revolutionary by itself, as programmers can then write tools and programs in a higher level structured language, rather than in low-level assembly languages as in the operating systems before. As a result of this development, Unix is the first operating system where programmers can write and run a program on the fly in front of a terminal. This ability leads to a plethora of contributions to Unix systems, utilities, and tools in the 1970s, fueling its popularity among the developers. The ease of programming and its superiority in terms of simplicity has lead to the emergence of variants of the original Unix operating systems, developed by modifying the original Unix source code. The Berkeley Software Distribution (BSD) is among the most important ones (macOS is a descendant of BSD). Another notable descendant from the original Unix is Solaris, from Sun Microsystem (now Oracle), which the School of Computing runs on its computing server (called sunfire ). Another variant of Unix is Linux -- which interestingly is developed from scratch as a hobby initially by Linus Torvalds at the age of 21. Linux follows many of the principles of Unix but is not based on the original Unix source code. Figure: Unix and Unix-like Operating Systems. While a majority of personal computers is still running Microsoft Windows 10 (88%), a vast majority of server software is running on some flavor of Unix (>70%) 1 . Almost all mobile phones are running on a variant of Unix (iOS, Android). Among software developers, more than half (53%) uses a Unix-based OS on the primary work machines 2 . Microsoft, after years of competing with Unix-based OS, has started to embrace Unix-based systems and released the Windows Subsystems for Linux, allowing Windows users to run a sandboxed Linux subsystems within Windows. We collectively call these variants of operating systems and subsystems the Unix computing environment , which today includes all OS from Apple (macOS, iOS, etc), Linux-based systems (Ubuntu, Android, etc), commercial servers (Oracle's Solaris, HP's HP-UX, IBM's AIX), and subsystems within Microsoft Windows 10.","title":"History of Unix"},{"location":"why-unix/#why-learn-unix","text":"There are several reasons: Unix-based OS is the dominant operating system in the world, and as a computing student, you will likely have to interface with one sometime in your career. Unix design is rooted in its simplicity and economy. It is probably the most productive programming environment you can have to do most of your day-to-day tasks and to develop software as a computing professional. Unix design is also rooted in its programmability. If there is something that you wish to automate a task to improve your productivity, you can easily compose new tools from the existing ones. The Unix philosophy serves as a great example of how good software should be designed: simple, do one thing well, composable.","title":"Why Learn Unix?"},{"location":"why-unix/#further-readings","text":"The Art of Unix Programming: History of Unix , by Eric Steven Raymond Stack Overflow Developer Survey 2020 \u21a9 Usage Share of OS , by Wikipedia \u21a9 The Unix Time Sharing System , by Dennis Ritchie and Ken Thompson. \u21a9","title":"Further Readings"},{"location":"wsl/","text":"Setting Up Unix Computing Environment on Windows 10 with WSL WSL, or Windows Subsystem for Linux , is a subsystem that allows users to run a Unix computing environment within Windows 10. This is the recommended method for having a local Unix computing environment for your Windows 10 machine, for the purpose of CS1010, CS2030, CS2030S, and CS2040 in Semester 1, AY2020/21. There are two versions, WSL 1 and, a newer, WSL 2. For the Unix@Home workshop, it suffices for attendees to install WSL 1. Requirements Before you proceed with the instructions below, you need to make sure that: You have 64-bit versions of Windows 10, version 1607 or higher ( Here is how you check ); You have administrator access to your Windows 10; And You have an SoC Unix account. You can create an SoC Unix account here . For SoC students, this username is something that sticks with you for the rest of your SoC life -- so choose wisely. Installing WSL 1 Step 1: Enabling WSL on Windows 10 through PowerShell Before you install WSL 1, you need to first enable the \"Windows Subsystem for Linux\" feature by running the following command in PowerShell. dism . exe / online / enable-feature / featurename : Microsoft-Windows-Subsystem-Linux / all / norestart You can achieve this step by: Hit Win to open the Start menu, type PowerShell , then right-click on Windows PowerShell, and click \"Run as administrator\" Copy the command above by selecting it and then hitting Ctrl + C Go to your PowerShell window and paste the command above by hitting Ctrl + V . Press enter if needed to run the command. Step 2: Restart your computer Step 3: Install Ubuntu After restarting your computer, go to the Microsoft Store and get Ubuntu . Follow the on-screen instructions to install. When you are asked to create a user account and password, we suggest that you choose a Unix username that is that same as your SoC Unix username. Launching WSL To launch WSL, you can hit Win + R and type in Ubuntu followed by Enter . This should bring up the Unix command-line interface for you to interact with the Unix computing environment. Getting ready to install tools WSL comes with apt as the package manager, which is a convenient way to list, search, install, update, and uninstall software and libraries in WSL. After you have set up WSL, run the following: sudo apt update What it does: apt is a command to install, upgrade, search, and uninstall software and other packages in Ubuntu. apt update asks apt to obtain the latest list of available packages from the Internet. sudo performs apt update with a super-user's level permission. This command may ask you to enter your password. (Note: super-user means administrator in Unix).","title":"Setup for Windows 10"},{"location":"wsl/#setting-up-unix-computing-environment-on-windows-10-with-wsl","text":"WSL, or Windows Subsystem for Linux , is a subsystem that allows users to run a Unix computing environment within Windows 10. This is the recommended method for having a local Unix computing environment for your Windows 10 machine, for the purpose of CS1010, CS2030, CS2030S, and CS2040 in Semester 1, AY2020/21. There are two versions, WSL 1 and, a newer, WSL 2. For the Unix@Home workshop, it suffices for attendees to install WSL 1.","title":"Setting Up Unix Computing Environment on Windows 10 with WSL"},{"location":"wsl/#requirements","text":"Before you proceed with the instructions below, you need to make sure that: You have 64-bit versions of Windows 10, version 1607 or higher ( Here is how you check ); You have administrator access to your Windows 10; And You have an SoC Unix account. You can create an SoC Unix account here . For SoC students, this username is something that sticks with you for the rest of your SoC life -- so choose wisely.","title":"Requirements"},{"location":"wsl/#installing-wsl-1","text":"","title":"Installing WSL 1"},{"location":"wsl/#step-1-enabling-wsl-on-windows-10-through-powershell","text":"Before you install WSL 1, you need to first enable the \"Windows Subsystem for Linux\" feature by running the following command in PowerShell. dism . exe / online / enable-feature / featurename : Microsoft-Windows-Subsystem-Linux / all / norestart You can achieve this step by: Hit Win to open the Start menu, type PowerShell , then right-click on Windows PowerShell, and click \"Run as administrator\" Copy the command above by selecting it and then hitting Ctrl + C Go to your PowerShell window and paste the command above by hitting Ctrl + V . Press enter if needed to run the command.","title":"Step 1: Enabling WSL on Windows 10 through PowerShell"},{"location":"wsl/#step-2-restart-your-computer","text":"","title":"Step 2: Restart your computer"},{"location":"wsl/#step-3-install-ubuntu","text":"After restarting your computer, go to the Microsoft Store and get Ubuntu . Follow the on-screen instructions to install. When you are asked to create a user account and password, we suggest that you choose a Unix username that is that same as your SoC Unix username.","title":"Step 3: Install Ubuntu"},{"location":"wsl/#launching-wsl","text":"To launch WSL, you can hit Win + R and type in Ubuntu followed by Enter . This should bring up the Unix command-line interface for you to interact with the Unix computing environment.","title":"Launching WSL"},{"location":"wsl/#getting-ready-to-install-tools","text":"WSL comes with apt as the package manager, which is a convenient way to list, search, install, update, and uninstall software and libraries in WSL. After you have set up WSL, run the following: sudo apt update What it does: apt is a command to install, upgrade, search, and uninstall software and other packages in Ubuntu. apt update asks apt to obtain the latest list of available packages from the Internet. sudo performs apt update with a super-user's level permission. This command may ask you to enter your password. (Note: super-user means administrator in Unix).","title":"Getting ready to install tools"}]}